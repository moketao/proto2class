package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

//https://mholt.github.io/json-to-go/
//https://studygolang.com/articles/6112
type Message struct {
	Name string `json:"name"`
	LongName string `json:"longName"`
	FullName string `json:"fullName"`
	Desc string `json:"description"`
	HasExtensions bool `json:"hasExtensions"`
	HasFields bool `json:"hasFields"`
	Extensions []interface{} `json:"extensions"`
	Code int
	IsEnum bool
	Fields []struct {
		Name string `json:"name"`
		Desc string `json:"description"`
		Label string `json:"label"`
		Type string `json:"type"`
		LongType string `json:"longType"`
		FullType string `json:"fullType"`
		DefaultValue string `json:"defaultValue"`
	} `json:"fields"`
}
type Enum struct {
	Name string `json:"name"`
	LongName string `json:"longName"`
	FullName string `json:"fullName"`
	Desc string `json:"description"`
	IsEnum bool
	Values []struct {
		Name string `json:"name"`
		Number string `json:"number"`
		Desc string `json:"description"`
	} `json:"values"`
}
type File struct {
	Name string `json:"name"`
	Desc string `json:"description"`
	Package string `json:"package"`
	HasEnums bool `json:"hasEnums"`
	HasExtensions bool `json:"hasExtensions"`
	HasMessages bool `json:"hasMessages"`
	HasServices bool `json:"hasServices"`
	Enums []*Enum `json:"enums"`
	Extensions []interface{} `json:"extensions"`
	Messages []*Message `json:"messages"`
	Services []interface{} `json:"services"`
}
type AutoGenerated struct {
	Files []File `json:"files"`
}

var idDic map[string]int
var idFile *string
var templatePath *string
var outputPath *string
var ext *string
var filters *string
var filterArr []string

func main() {
	templatePath = flag.String("f", "./tpl/one_proto.as", " -f your_template_file_name")
	outputPath = flag.String("t", "./js/handlers/", " -t your_output_dir")
	jsonFile := flag.String("data", "msg.json", " --data msg.json")
	idFile = flag.String("data2", "mapids.js", " --data2 mapids.js")
	ext = flag.String("ext", ".as", " -ext your_file_ext")
	filters = flag.String("filters", "Req", " -filters Rsp,Notify")
	flag.Parse()

	filterArr = strings.Split(*filters,",")

	var e error

	jsonFileBytes, e := ioutil.ReadFile(*jsonFile)
	ifErr("jsonFile读取失败",e)

	idFileBytes, e := ioutil.ReadFile(*idFile)
	ifErr("idFile读取失败：", e)

	var protoMap map[string]interface{}
	e = json.Unmarshal(jsonFileBytes, &protoMap)
	ifErr("jsonFileBytes格式不正确：", e)

	e = json.Unmarshal(idFileBytes, &idDic)
	ifErr("idFileBytes格式不正确：", e)

	var body AutoGenerated
	e = json.Unmarshal(jsonFileBytes, &body)
	ifErr("解析失败",e)

	for _,file:=range body.Files {
		doFile(&file)
	}
}


func doFile(file *File)  {

	functionMap := template.FuncMap{
		"counter": counter,
		"toAsType": toAsType,
		"hasSuffix": HasSuffix,
		"hasPrefix": HasPrefix,
	}

	tpl, e := template.New(filepath.Base(*templatePath)).Funcs(functionMap).ParseFiles(*templatePath)
	ifErr("模板创建失败：", e)
	var count int
	if *filters=="" {
		for _, v := range file.Enums {
			v.IsEnum = true
			opt := os.O_CREATE | os.O_TRUNC | os.O_RDWR
			f, e := os.OpenFile(*outputPath+v.Name+(*ext), opt, 0777)
			ifErr("创建文件失败", e)

			e = tpl.Execute(f, v)
			ifErr("模板执行出错", e)

			count = count + 1
		}
	}
	for _, v := range file.Messages {
		v.Code = idDic[v.Name]
		v.IsEnum = false

		if *filters!="" {
			//如果要生成 Handler ，需要先过滤，以免现有 Handler 被覆盖。
			var need bool
			if HasSuffixInFilter(v.Name, filterArr) {
				need = true
			}
			if !need {
				continue
			}
			if Exist(*outputPath + v.Name + (*ext)) {
				fmt.Println(*outputPath+v.Name+(*ext), "对应的 Handler 逻辑已存在，不再重新创建")
				continue
			}
		}

		opt := os.O_CREATE | os.O_TRUNC | os.O_RDWR
		f, e := os.OpenFile(*outputPath+v.Name+(*ext), opt, 0777)
		ifErr("创建文件失败",e)
		count = count + 1

		e = tpl.Execute(f, v)
		ifErr("模板执行出错",e)
	}
	fmt.Println("生成文件数量:", count)
}

func HasSuffixInFilter(s string,arr []string) bool  {
	for _,v:=range arr{
		if HasSuffix(s,v){
			return true
		}
	}
	return false
}

func HasSuffix(s string,suffix string) bool  {
	return strings.HasSuffix(s,suffix)
}

func HasPrefix(s string,prefix string) bool  {
	return strings.HasPrefix(s,prefix)
}

// 检查文件或目录是否存在
// 如果由 filename 指定的文件或目录存在则返回 true，否则返回 false
func Exist(filename string) bool {
	_, err := os.Stat(filename)
	return err == nil || os.IsExist(err)
}

func ifErr(str string , err error)  {
	if err != nil {
		fmt.Println(str, err)
		os.Exit(1)
	}
}

func counter() func() int {
	i := -1
	return func() int {
		i++
		return i
	}
}
func toAsType(s string) string {
	if strings.Contains(s, "Array") {
		return "Array=[]"
	}
	if strings.Contains(s, "number") {
		return "Number=0"
	}
	if strings.Contains(s, "string") {
		return `String=""`
	}
	if strings.Contains(s, "$EN") {
		return "int"
	}
	return "*"
}